from __future__ import annotations

import base64
import io
import logging
import mimetypes
import os
import time
from pathlib import Path

from PIL import Image, ImageOps

logger = logging.getLogger(__name__)


PROMPT_GUARDRAIL = (
    "请尽可能保持原图构图、视角、主体位置与材质不变，仅根据需求进行最小必要修改，"
    "避免大幅重绘、避免风格突变、避免替换无关元素。"
)


def _iter_response_parts(response):
    parts = getattr(response, "parts", None)
    if parts:
        return parts
    candidates = getattr(response, "candidates", None) or []
    if candidates:
        return getattr(candidates[0].content, "parts", None) or []
    return []


def _image_to_data_url(image_path: Path) -> str:
    mime_type = mimetypes.guess_type(image_path.name)[0] or "image/png"
    return f"data:{mime_type};base64,{base64.b64encode(image_path.read_bytes()).decode('utf-8')}"


def _revise_prompt_with_gpt52(source_image_path: Path, desired_image_prompt: str, model: str = "gpt-5.2") -> str:
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        return f"{PROMPT_GUARDRAIL}\n\n需求：{desired_image_prompt}"

    try:
        from openai import OpenAI
    except Exception:
        return f"{PROMPT_GUARDRAIL}\n\n需求：{desired_image_prompt}"

    client = OpenAI(api_key=api_key)
    system = (
        "你是住区更新图生图提示词改写专家。你要根据输入现场图片与目标需求，"
        "输出一段可直接用于图像编辑模型的中文prompt。"
        "必须强调可实施性：如对象是否可以移动/移除、是否会挤占过道、是否影响安全与通行。"
        "只输出最终prompt文本，不要输出解释。"
    )
    user = (
        f"原始需求：{desired_image_prompt}\n\n"
        f"请改写为真实可落地的图生图prompt，并包含以下约束：\n"
        f"- {PROMPT_GUARDRAIL}\n"
        "- 改造应充分考虑可行性，不得提出不现实的大拆大改。\n"
        "- 不得堵塞主要通道，不得引入明显安全隐患。"
    )

    try:
        resp = client.responses.create(
            model=model,
            input=[
                {"role": "system", "content": [{"type": "input_text", "text": system}]},
                {
                    "role": "user",
                    "content": [
                        {"type": "input_text", "text": user},
                        {"type": "input_image", "image_url": _image_to_data_url(source_image_path)},
                    ],
                },
            ],
            temperature=0.2,
        )
        revised = (resp.output_text or "").strip()
        if revised:
            logger.info("[image_generation] revised prompt generated by gpt-5.2")
            return revised
    except Exception as exc:
        logger.warning("[image_generation] prompt revision failed, fallback to original prompt. err=%s", exc)

    return f"{PROMPT_GUARDRAIL}\n\n需求：{desired_image_prompt}"




def _normalize_image_orientation(img: Image.Image) -> Image.Image:
    """Apply EXIF orientation so portrait/landscape is consistent before concat."""
    return ImageOps.exif_transpose(img).convert("RGB")

def _part_to_image(part) -> Image.Image | None:
    if not (getattr(part, "inline_data", None) and getattr(part.inline_data, "data", None)):
        return None

    data = part.inline_data.data
    if isinstance(data, (bytes, bytearray)):
        image_bytes = bytes(data)
    else:
        image_bytes = base64.b64decode(data)

    # Preferred path: decode inline bytes directly.
    try:
        return _normalize_image_orientation(Image.open(io.BytesIO(image_bytes)))
    except Exception:
        # Fallback for SDK variants/mocks where inline bytes are placeholders but
        # `part.as_image()` returns a valid image object.
        as_img = getattr(part, "as_image", None)
        if callable(as_img):
            obj = as_img()
            if hasattr(obj, "save"):
                if isinstance(obj, Image.Image):
                    return _normalize_image_orientation(obj)
                buf = io.BytesIO()
                obj.save(buf, format="PNG")
                buf.seek(0)
                return _normalize_image_orientation(Image.open(buf))
        raise


def _concat_side_by_side(original_image: Image.Image, edited_image: Image.Image) -> Image.Image:
    # Keep same height for side-by-side concat: old on left, new on right.
    target_h = max(original_image.height, edited_image.height)

    def resize_to_h(img: Image.Image, h: int) -> Image.Image:
        if img.height == h:
            return img
        w = max(1, int(img.width * (h / img.height)))
        return img.resize((w, h), Image.Resampling.LANCZOS)

    left = resize_to_h(_normalize_image_orientation(original_image), target_h)
    right = resize_to_h(_normalize_image_orientation(edited_image), target_h)

    canvas = Image.new("RGB", (left.width + right.width, target_h), color=(255, 255, 255))
    canvas.paste(left, (0, 0))
    canvas.paste(right, (left.width, 0))
    return canvas


def edit_image_with_gemini_nanobanana(
    prompt: str,
    source_image_path: str | Path,
    output_path: str | Path,
    model: str = "gemini-3-pro-image-preview",
) -> str:
    """Image-to-image editing via Gemini image generation API.

    Saves a side-by-side comparison image: original(left) + edited(right).
    """
    logger.info("[image_generation] start edit model=%s source=%s", model, source_image_path)
    api_key = os.getenv("GEMINI_API_KEY") or os.getenv("GOOGLE_API_KEY")
    if not api_key:
        raise RuntimeError("GEMINI_API_KEY or GOOGLE_API_KEY is required for Gemini image editing")

    source_image_path = Path(source_image_path)
    if not source_image_path.exists():
        raise FileNotFoundError(f"Source image not found: {source_image_path}")

    try:
        from google import genai
        from google.genai import types
    except Exception as exc:  # pragma: no cover
        raise ImportError("Install `google-genai` to use Gemini image editing") from exc

    client = genai.Client(api_key=api_key)
    img_bytes = source_image_path.read_bytes()
    mime_type = mimetypes.guess_type(source_image_path.name)[0] or "image/png"

    revised_prompt = _revise_prompt_with_gpt52(source_image_path, prompt, model="gpt-5.2")

    response = None
    last_exc: Exception | None = None
    for attempt in range(1, 6):
        try:
            response = client.models.generate_content(
                model=model,
                contents=[
                    types.Part.from_text(text=revised_prompt),
                    types.Part.from_bytes(data=img_bytes, mime_type=mime_type),
                ],
                config=types.GenerateContentConfig(
                    response_modalities=["IMAGE"],
                    image_config=types.ImageConfig(image_size="2K"),
                ),
            )
            break
        except Exception as exc:
            last_exc = exc
            wait_s = min(2 ** (attempt - 1), 8)
            logger.warning(
                "[image_generation] Gemini request failed attempt=%s/5 wait=%ss err=%s",
                attempt,
                wait_s,
                exc,
            )
            if attempt < 5:
                time.sleep(wait_s)

    if response is None:
        raise RuntimeError(f"Gemini request failed after retries: {last_exc}") from last_exc

    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    original = _normalize_image_orientation(Image.open(source_image_path))
    for part in _iter_response_parts(response):
        if getattr(part, "text", None):
            logger.info("[image_generation] Gemini text response: %s", part.text)

        edited = _part_to_image(part)
        if edited is not None:
            merged = _concat_side_by_side(original, edited)
            merged.save(output_path)
            logger.info("[image_generation] saved side-by-side image -> %s", output_path)
            return str(output_path)

    raise RuntimeError("Gemini did not return an edited image payload")
